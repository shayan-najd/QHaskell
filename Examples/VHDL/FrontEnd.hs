module Examples.VHDL.FrontEnd where

import Control.Applicative

import QHaskell
import QHaskell.Expression.GADTFirstOrder
import QHaskell.Expression.Utils.GADTFirstOrder (substitute)
import QHaskell.Variable.Typed

import qualified Examples.VHDL.BackEnd as BE
import Examples.VHDL.BackEnd (NameMonad,newVar,runNameMonad)

-----------------------------------------------------------------------
-- Defining the QDSL front-end
-----------------------------------------------------------------------

inv :: Bool -> Bool
inv = not

and2 :: Bool -> Bool -> Bool
and2 = (&&)

or2 :: Bool -> Bool -> Bool
or2 = (||)

xor2 :: Bool -> Bool -> Bool
xor2 m n = if m then not n else n

delay :: Bool -> Bool -> Bool
delay = undefined

makeQDSL "Lava" ['inv,'and2,'or2,'xor2,'delay]

-- todo: below patterns should be generated by above too
pattern InvVar   m   = App (Var Zro) m
pattern And2Var  m n = App (App (Var (Suc Zro)) m) n
pattern Or2Var   m n = App (App (Var (Suc (Suc Zro))) m) n
pattern Xor2Var  m n = App (App (Var (Suc (Suc (Suc Zro)))) m) n
pattern DelayVar m n = App (App (Var (Suc (Suc (Suc (Suc Zro))))) m) n

-----------------------------------------------------------------------
-- connecting the QDSL front-end to the back-end
-----------------------------------------------------------------------

-- | compiles the given quotation to VHDL,
--   or returns runtime error
compile :: Qt (Bool -> Bool) -> String
compile q = case translate q of
  Rgt l ->  let l' = runNameMonad (toBackEndF l)
            in  BE.vhdl "prog" ["x1"] [l']
  Lft s -> error s

-- | Conversion from the front-end representation (QHaskell's output),
--   to the back-end representation
toBackEnd :: Lava a -> NameMonad BE.Exp
toBackEnd l = case l of
  ConB     b   -> pure (BE.Bool  b)
  Fst      m   -> toBackEnd1 BE.Fst   m
  Snd      m   -> toBackEnd1 BE.Snd   m
  Tpl      m n -> toBackEnd2 BE.Pair  m n
  InvVar   m   -> toBackEnd1 BE.Inv   m
  And2Var  m n -> toBackEnd2 BE.And   m n
  Or2Var   m n -> toBackEnd2 BE.Or    m n
  Xor2Var  m n -> toBackEnd2 BE.Xor   m n
  DelayVar m n -> toBackEnd2 BE.Delay m n
  Fix (Abs n)  -> do i <- newVar
                     BE.Fix ("x" ++ show i)
                       <$> toBackEnd (substitute (Int i) n)
  Let      m n -> do i <- newVar
                     BE.Let ("x" ++ show i) <$> toBackEnd m
                       <*> toBackEnd (substitute (Int i) n)
  Int i        -> pure (BE.VarB ("x" ++ show i))
  Tag _ m      -> toBackEnd m
  Mem m        -> toBackEnd m
  Fix _        -> badNormalisation
  ConI _       -> badNormalisation
  ConF _       -> badNormalisation
  Abs  _       -> badNormalisation
  Var  _       -> badNormalisation
  App  _ _     -> badNormalisation
  Non          -> badNormalisation
  Som _        -> badNormalisation
  May _ _ _    -> badNormalisation
 where
   toBackEnd1 :: (BE.Exp -> BE.Exp) -> Lava a -> NameMonad BE.Exp
   toBackEnd1 c m = c <$> toBackEnd m

   toBackEnd2 :: (BE.Exp -> BE.Exp -> BE.Exp) ->
                 Lava a -> Lava b -> NameMonad BE.Exp
   toBackEnd2 c m n = c <$> toBackEnd m <*> toBackEnd n

   badNormalisation = fail "Invalid normal form!"

toBackEndF :: Lava (Bool -> Bool) -> NameMonad BE.Exp
toBackEndF (Abs n) = do i <- newVar
                        toBackEnd (substitute (Int i) n)
toBackEndF _       = fail "Invalid normal form!"

-----------------------------------------------------------------------
-- Example
-----------------------------------------------------------------------

low :: Qt Bool
low = [|| False ||]

toggle :: Qt (Bool -> Bool)
toggle = [|| \ change ->
              let out' = delay $$low out
                  out  = xor2 change out'
              in  out ||]
