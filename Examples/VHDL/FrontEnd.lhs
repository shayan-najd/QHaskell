> module Examples.VHDL.FrontEnd where

      QHaskell, a Tool for Implementing Quoted DSLs in Haskell
                     Shayan Najd - June 2015
=====================================================================

Abstract
--------
In this note, I present QHaskell, a tool for implementing Quoted DSLs
(QDSLs) in Haskell neatly and quickly.

Introduction
------------
QHaskell provides a framework to facilitate implementing QDSLs in
Haskell. It comes with a set of generic algorithms for transforming
the high-level Haskell code in quasi-quotes to a tiny language
suitable for reasoning and generating efficient code.

To explain the process of implementing a QDSL with QHaskell, we
implement a QDSL front-end for Bjesse, Claessen, Sheeran, and Singh's
Lava. Lava is a well-known DSL for describing electronic circuits.

In order to use QHaskell, we should first import tool's main module.

> import QHaskell
 
Then, we should define a set of functions representing language
primitives.

The following represents the primitives in Lava:

> ---------------------------------------------------------------------
> -- Defining the QDSL front-end
> ---------------------------------------------------------------------
>
> inv :: Bool -> Bool
> inv = not
>
> and2 :: Bool -> Bool -> Bool
> and2 = (&&)
>
> or2 :: Bool -> Bool -> Bool
> or2 = (||)
>
> xor2 :: Bool -> Bool -> Bool
> xor2 m n = if m then not n else n
>
> delay :: Bool -> Bool -> Bool
> delay = undefined
 
The name and type of the functions are used for type checking the
quoted terms. If provided, the body of functions can be used for
evaluating the quoted terms.

Once the set of language primitives are defined, we can ask QHaskell
to generate the required machinery automatically:

> makeQDSL "Lava" ['inv,'and2,'or2,'xor2,'delay]
>
> -- todo: below patterns should be generated by above too
> pattern InvVar   m   = Prm Zro (Ext m Emp)
> pattern And2Var  m n = Prm (Suc Zro) (Ext m (Ext n Emp))
> pattern Or2Var   m n = Prm (Suc (Suc Zro)) (Ext m (Ext n Emp))
> pattern Xor2Var  m n = Prm (Suc (Suc (Suc Zro))) (Ext m (Ext n Emp))
> pattern DelayVar m n = Prm (Suc (Suc (Suc (Suc Zro))))
>                        (Ext m (Ext n Emp))

The meta-function |makeQDSL| takes the name of the DSL in |String|,
together with a list of the names of the Haskell functions
representing language primitives. Name of an entity in Haskell can be
made avaialbe as a value by putting a single quote before the name of
the entity. In particular, |makeQDSL| provides the following:

(a) Intermediate Representation (IR):
    a type synonym of the name provided by the user, referring to
    QHaskell's generic IR fixed to include only the specified
    primitives. For more information about the IR refer to the module
    |QHaskell.Expression.GADTFirstOrder|.

    (ToDo: add haddock in there)

(b) Translator:
    a function that translates the quoted terms of type |Qt a| to
    terms of IR. For Lava, we get the following function:

    < translate :: Type a => Qt a -> ErrM (Lava a)

(c) Normaliser:
    a function that normalises the given terms. For more information
    on the normalisation process refer to our draft paper "Everything
    old is new again: Quoted Domain Specific Languages". For Lava, we
    get the following function:

    < normalise :: Type a => Lava a -> Lava a

(d) Evaluator:
    a function that evaluates the given term. If provided, it uses the
    body of the Haskell functions representing DSL language primitives.
    The type of the evaluator for a QDSL T is the following:
 
    < evaluate :: Type a => T a -> a

The constraint |Type a| above, automatically provides a term-level
representation of types.

Having the front-end in place the next step is to glue it to the
back-end. For our running example's back-end, refer to the module
|Examples.VHDL.BackEnd|, for the "glue" code refer to
|Examples.VHDL.Glue|.
