module Examples.VHDL.Glue where

import Control.Applicative

import QHaskell

import Examples.VHDL.FrontEnd
import qualified Examples.VHDL.BackEnd as BE
import Examples.VHDL.BackEnd (NameMonad,newVar,runNameMonad)


---------------------------------------------------------------------
-- connecting the QDSL front-end to the back-end
---------------------------------------------------------------------

-- | compiles the given quotation to VHDL,
--   or returns runtime error
compile :: (Type a, ToBackEnd a) => Qt a -> String
compile q = case translate q of
  Rgt l ->  let l' = runNameMonad (toBackEndO (normalise l))
            in  BE.vhdl "prog" ["x1"] [l']
  Lft s -> error s

-- | Conversion from the front-end representation
--  (QHaskell's output), to the back-end representation
toBackEnd :: Lava a -> NameMonad BE.Exp
toBackEnd l = case l of
  ConB     b   -> pure (BE.Bool  b)
  Fst      m   -> toBackEnd1 BE.Fst   m
  Snd      m   -> toBackEnd1 BE.Snd   m
  Tpl      m n -> toBackEnd2 BE.Pair  m n
  InvVar   m   -> toBackEnd1 BE.Inv   m
  And2Var  m n -> toBackEnd2 BE.And   m n
  Or2Var   m n -> toBackEnd2 BE.Or    m n
  Xor2Var  m n -> toBackEnd2 BE.Xor   m n
  DelayVar m n -> toBackEnd2 BE.Delay m n
  Fix (Abs n)  -> do i <- newVar
                     BE.Fix ("x" ++ show i)
                       <$> toBackEnd (substitute (Int i) n)
  LeT      m n -> do i <- newVar
                     BE.Let ("x" ++ show i) <$> toBackEnd m
                       <*> toBackEnd (substitute (Int i) n)
  Cnd  c m n   -> do c' <- toBackEnd c
                     m' <- toBackEnd m
                     n' <- toBackEnd n
                     return (BE.Or (BE.And c' m')
                             (BE.And (BE.Inv c') n'))
  Int i        -> pure (BE.VarB ("x" ++ show i))
  Tag _ m      -> toBackEnd m
  Mem m        -> toBackEnd m
  Fix _        -> badNormalisation
  ConI _       -> badNormalisation
  ConF _       -> badNormalisation
  Abs  _       -> badNormalisation
  Var  _       -> badNormalisation
  App  _ _     -> badNormalisation
  Prm  _ _     -> badNormalisation
 where
   toBackEnd1 :: (BE.Exp -> BE.Exp) -> Lava a -> NameMonad BE.Exp
   toBackEnd1 c m = c <$> toBackEnd m

   toBackEnd2 :: (BE.Exp -> BE.Exp -> BE.Exp) ->
                 Lava a -> Lava b -> NameMonad BE.Exp
   toBackEnd2 c m n = c <$> toBackEnd m <*> toBackEnd n

   badNormalisation = fail "Invalid normal form!"

toBackEndF :: Lava (Bool -> Bool) -> NameMonad BE.Exp
toBackEndF (Abs n) = do i <- newVar
                        toBackEnd (substitute (Int i) n)
toBackEndF _       = fail "Invalid normal form!"

class ToBackEnd a where
  toBackEndO :: Lava a -> NameMonad BE.Exp

instance ToBackEnd Bool where
  toBackEndO = toBackEnd

instance ToBackEnd r => ToBackEnd (Bool -> r) where
  toBackEndO (Abs n) = do i <- newVar
                          toBackEndO (substitute (Int i) n)
  toBackEndO _       = fail "Invalid normal form!"

instance ToBackEnd (a,b) where
  toBackEndO = toBackEnd

-----------------------------------------------------------------------
-- Example
-----------------------------------------------------------------------

low :: Qt Bool
low = [|| False ||]

toggle :: Qt (Bool -> Bool)
toggle = [|| \ change ->
              let out' = delay $$low out
                  out  = xor2 change out'
              in  out ||]

vhdlToggle :: IO ()
vhdlToggle = putStrLn (compile toggle)

-- Above generates the following:
{-
-- Generated by Lava 2000

use work.all;

entity
  prog
is
port
  -- clock
  ( clk : in bit

  -- inputs
  ; x1 : in bit

  -- outputs
  ; outp_0 : out bit
  );
end entity prog;

architecture
  structural
of
  prog
is
  signal w4 : bit;
  signal w5 : bit;
  signal w8 : bit;
begin
  c_w4      : entity xor2  port map (clk, x1, w5, w4);
  c_w5      : entity delay port map (clk, w8, w4, w5);
  c_w8      : entity gnd   port map (clk, w8);

  -- naming outputs
  c_outp_0  : entity id    port map (clk, w4, outp_0);
end structural;
-}
